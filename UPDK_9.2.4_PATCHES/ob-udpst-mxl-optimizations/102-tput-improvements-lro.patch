diff -Naur a/config.h.cmake b/config.h.cmake
--- a/config.h.cmake	2025-09-19 15:48:49.602064865 +0530
+++ b/config.h.cmake	2025-09-19 16:03:40.509391030 +0530
@@ -15,7 +15,6 @@
 #cmakedefine HAVE_WORKING_FORK
 #cmakedefine HAVE_SENDMMSG
 #cmakedefine HAVE_GSO
-#cmakedefine HAVE_RECVMMSG
 #cmakedefine DISABLE_INT_TIMER
 #cmakedefine RATE_LIMITING
 #cmakedefine AUTH_IS_OPTIONAL
diff -Naur a/udpst_control.c b/udpst_control.c
--- a/udpst_control.c	2025-09-19 15:49:25.417232012 +0530
+++ b/udpst_control.c	2025-09-19 16:03:47.137237551 +0530
@@ -1035,6 +1035,19 @@
         tspecplus(&repo.systemClock, &tspecvar, &c->timer3Thresh);
         c->timer3Action = &stop_test;
 
+#if defined(MXL_OPT)
+        int val2 = 1;
+
+        int opt_name = OB_UDPST;
+        if (c->ipProtocol == IPPROTO_IPV6)
+                opt_name = OB_UDPST6;
+
+        if(setsockopt(c->fd, IPPROTO_UDP, opt_name, &val2, sizeof(val2)) < 0) {
+                var = sprintf(scratch, "SET OB_UDPST ERROR: %s\n", strerror(errno));
+                send_proc(errConn, scratch, var);
+                return -1;
+        }
+#endif
         return 0;
 }
 //----------------------------------------------------------------------------
@@ -1358,6 +1371,21 @@
         tspecplus(&repo.systemClock, &tspecvar, &c->timer3Thresh);
         c->timer3Action = &stop_test;
 
+#if defined(MXL_OPT)
+        if ((c->testType == TEST_TYPE_DS)) {
+                int val2 = 1;
+
+                int opt_name = OB_UDPST;
+                if (c->ipProtocol == IPPROTO_IPV6)
+                        opt_name = OB_UDPST6;
+
+                if(setsockopt(c->fd, IPPROTO_UDP, opt_name, &val2, sizeof(val2)) < 0) {
+                        var = sprintf(scratch, "SET OB_UDPST ERROR: %s\n", strerror(errno));
+                        send_proc(errConn, scratch, var);
+                        return -1;
+                }
+        }
+#endif
         return 0;
 }
 //----------------------------------------------------------------------------
diff -Naur a/udpst_data.c b/udpst_data.c
--- a/udpst_data.c	2025-09-19 15:50:11.712155690 +0530
+++ b/udpst_data.c	2025-09-19 16:03:53.669086290 +0530
@@ -879,12 +879,26 @@
 int service_loadpdu(int connindex) {
         register struct connection *c = &conn[connindex];
         int i, delta, var;
+#if defined(MXL_OPT)
+        int ivar;
+#endif
         BOOL bvar, firstpdu = FALSE;
         unsigned int uvar, seqno, rttrd, payload;
+#if defined(MXL_OPT)
+        struct loadHdr *lHdr = (struct loadHdr *) repo.defBuffer;
+        int udpPayloadRem = repo.rcvDataSize;
+        char *nextSeg = repo.defBuffer;
+        int udpSegLen;
+
+#else
         struct loadHdr *lHdr = (struct loadHdr *) repo.rcvDataPtr;
+#endif
         struct timespec tspecvar, tspecdelta;
         char *nulloutput = ",,,,,\n";
 
+#if defined(MXL_OPT)
+lbl_nextlhdr_gro:
+#endif
         //
         // Verify PDU
         //
@@ -1023,7 +1037,11 @@
                 if (c->outputFPtr != NULL) { // Finalize output data with null entries
                         fputs(nulloutput, c->outputFPtr);
                 }
+#if defined(MXL_OPT)
+                goto next_hdr_check;
+#else
                 return 0; // No further processing for non-increasing sequence numbers
+#endif //MXL_OPT
         }
 
         //
@@ -1114,6 +1132,18 @@
                 c->sisAct.delayVarSum += (uint32_t) uvar;
                 c->sisAct.delayVarCnt++;
         }
+#if defined(MXL_OPT)
+next_hdr_check:
+        udpSegLen = sizeof(struct loadHdr);
+        if (udpSegLen < udpPayloadRem) {
+                // We have received UDP_GRO segment with multiple lHdr,
+                // so iterate to next lHdr.
+                nextSeg += udpSegLen;
+                lHdr = (struct loadHdr *) nextSeg;
+                udpPayloadRem -= udpSegLen;
+                goto lbl_nextlhdr_gro;
+        }
+#endif
         return 0;
 }
 //----------------------------------------------------------------------------
@@ -2371,11 +2401,15 @@
         //
         // Specify receive buffer size (truncate load PDUs to reduce overhead of memory copy)
         //
+#if defined(MXL_OPT)
+        recvsize = DEF_BUFFER_SIZE;
+#else
         if (c->secAction == &service_recvmmsg || c->secAction == &service_loadpdu) {
                 recvsize = RCV_HEADER_SIZE;
         } else {
                 recvsize = DEF_BUFFER_SIZE;
         }
+#endif
         repo.rcvDataPtr = repo.defBuffer; // Default to start of general I/O buffer
 
         //
diff -Naur a/udpst_protocol.h b/udpst_protocol.h
--- a/udpst_protocol.h	2025-09-19 15:48:46.458137983 +0530
+++ b/udpst_protocol.h	2025-09-19 16:04:02.048892243 +0530
@@ -47,7 +47,10 @@
 #define PROTOCOL_MIN  10 // Minimum protocol version for backward compatibility
 #define MULTIKEY_PVER 11 // Protocol version required for multi-key support
 #define CHECKSUM_PVER 11 // Protocol version required for checksum support
-#define OB_UDPST_GSO 107 
+
+#define OB_UDPST 105 // GRO option for IPv4
+#define OB_UDPST6 106 // GRO option for IPv6
+#define OB_UDPST_GSO 107 // GSO option for IPv4
 //----------------------------------------------------------------------------
 //
 // Sending rate structure for a single index (row) of transmission parameters
