diff -Naur a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2025-09-25 08:51:45.189239339 +0530
+++ b/CMakeLists.txt	2025-09-25 08:52:06.732716027 +0530
@@ -34,7 +34,7 @@
 set(CMAKE_INCLUDE_CURRENT_DIR ON)
 set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
 set(SOFTWARE_VER "8.2.0")
-set(MXL_RV_VER "2.1")
+set(MXL_RV_VER "2.2")
 
 INCLUDE (CheckIncludeFiles)
 INCLUDE (CheckFunctionExists)
diff -Naur a/udpst_data.c b/udpst_data.c
--- a/udpst_data.c	2025-09-25 08:50:41.830778739 +0530
+++ b/udpst_data.c	2025-09-25 08:49:26.192617243 +0530
@@ -333,116 +333,50 @@
         CMSG_CTL cctl;
 
 #if defined(MXL_OPT)
-        if (c->ipProtocol != IPPROTO_IPV6) {
-                while (totalburst > 0) {
-                        totalsize  = 0;
-                        nextsndbuf = sndbuf;
-                        struct gso_loadHdr *lHdr = (struct gso_loadHdr *) sndbuf;
-                        for (i = 0; i < totalburst; i++) {
-                                if (i < burstsize)
-                                        uvar = payload;
-                                else
-                                        uvar = addon;
-                                //
-                                // Check for GSO limits
-                                //
-                                if (i >= UDP_MAX_SEGMENTS) // Segment limit
-                                        break;
-                                if (totalsize + uvar > IP_MAXPACKET) // Size limit
-                                        break;
-                                if (i == 0) {
-                                        cctl = initializeGSO(c);
-                                }
-                                totalsize += uvar;
-                                nextsndbuf += payload;
-                        }
-                        // update initial pdu info...
-                        _gso_populate_header(lHdr, c, rttrd, totalsize, c->lpduSeqNo, uvar);    
-                        //
-                        // Setup message structure for buffer
-                        //
-                        iov[j].iov_base                = (void *) lHdr;
-                        iov[j].iov_len                 = sizeof(struct gso_loadHdr);
-                        mmsg[j].msg_hdr.msg_iov        = &iov[j];
-                        mmsg[j].msg_hdr.msg_iovlen     = 1;
-                        mmsg[j].msg_hdr.msg_control    = cctl.control;
-                        mmsg[j].msg_hdr.msg_controllen = cctl.msg_controllen;;
-                        j++;
-                        totalburst -= i;
-                        if (burstsize > 0)
-                                burstsize -= i;
-
-                        c->lpduSeqNo += (totalsize/uvar);
-                        //
-                        // Advance to next send buffer
-                        //
-                        sndbuf += DEF_BUFFER_SIZE;
-                }
-        } else {
-                while (totalburst > 0) {
-                        //
-                        // Fill send buffer until GSO limit or burst completion
-                        //
-                        totalsize  = 0;
-                        nextsndbuf = sndbuf;
-                        for (i = 0; i < totalburst; i++) {
-                                if (i < burstsize)
-                                        uvar = payload;
-                                else
-                                        uvar = addon;
-                                //
-                                // Check for GSO limits
-                                //
-                                if (i >= UDP_MAX_SEGMENTS) // Segment limit
-                                        break;
-                                if (totalsize + uvar > IP_MAXPACKET) // Size limit
-                                        break;
-                                //
-                                // Build load PDU (including corresponding control message on first one)
-                                //
-                                struct loadHdr *lHdr = (struct loadHdr *) nextsndbuf;
-                                _populate_header(lHdr, c, rttrd);
-                                lHdr->lpduSeqNo  = htonl((uint32_t) ++c->lpduSeqNo);
-                                lHdr->udpPayload = htons((uint16_t) uvar);
-#ifdef ADD_HEADER_CSUM
-                                if (c->protocolVer >= CHECKSUM_PVER)
-                                        lHdr->checkSum = checksum(lHdr, sizeof(struct loadHdr));
-#endif
-                                if (c->randPayload) {
-                                        _randomize_payload((char *) lHdr + sizeof(struct loadHdr), uvar - sizeof(struct loadHdr));
-                                }
-                                if (i == 0) {
-                                        cmsg->cmsg_len                  = GSO_CMSG_LEN;
-                                        cmsg->cmsg_level                = SOL_UDP;
-                                        cmsg->cmsg_type                 = UDP_SEGMENT;
-                                        *((uint16_t *) CMSG_DATA(cmsg)) = (uint16_t) uvar;
-                                }
-                                totalsize += uvar;
-                                nextsndbuf += payload;
+        while (totalburst > 0) {
+                totalsize  = 0;
+                nextsndbuf = sndbuf;
+                struct gso_loadHdr *lHdr = (struct gso_loadHdr *) sndbuf;
+                for (i = 0; i < totalburst; i++) {
+                        if (i < burstsize)
+                                uvar = payload;
+                        else
+                                uvar = addon;
+                        //
+                        // Check for GSO limits
+                        //
+                        if (i >= UDP_MAX_SEGMENTS) // Segment limit
+                                break;
+                        if (totalsize + uvar > IP_MAXPACKET) // Size limit
+                                break;
+                        if (i == 0) {
+                                cctl = initializeGSO(c);
                         }
-                        totalburst -= i;
-                        if (burstsize > 0)
-                                burstsize -= i;
-
-                        //
-                        // Setup message structure for buffer
-                        //
-                        iov[j].iov_base                = (void *) sndbuf;
-                        iov[j].iov_len                 = (size_t) totalsize;
-                        mmsg[j].msg_hdr.msg_iov        = &iov[j];
-                        mmsg[j].msg_hdr.msg_iovlen     = 1;
-                        mmsg[j].msg_hdr.msg_control    = cmsg;
-                        mmsg[j].msg_hdr.msg_controllen = GSO_CMSG_SIZE;
-                        j++;
-
-                        //
-                        // Advance to next send buffer
-                        //
-                        sndbuf += DEF_BUFFER_SIZE;
-                        cmsg = (struct cmsghdr *) ((char *) cmsg + GSO_CMSG_SIZE);
+                        totalsize += uvar;
+                        nextsndbuf += payload;
                 }
+                // update initial pdu info...
+                _gso_populate_header(lHdr, c, rttrd, totalsize, c->lpduSeqNo, uvar);    
+                //
+                // Setup message structure for buffer
+                //
+                iov[j].iov_base                = (void *) lHdr;
+                iov[j].iov_len                 = sizeof(struct gso_loadHdr);
+                mmsg[j].msg_hdr.msg_iov        = &iov[j];
+                mmsg[j].msg_hdr.msg_iovlen     = 1;
+                mmsg[j].msg_hdr.msg_control    = cctl.control;
+                mmsg[j].msg_hdr.msg_controllen = cctl.msg_controllen;;
+                j++;
+                totalburst -= i;
+                if (burstsize > 0)
+                        burstsize -= i;
 
-    }
+                c->lpduSeqNo += (totalsize/uvar);
+                //
+                // Advance to next send buffer
+                //
+                sndbuf += DEF_BUFFER_SIZE;
+        }
 #else
         while (totalburst > 0) {
                 //
