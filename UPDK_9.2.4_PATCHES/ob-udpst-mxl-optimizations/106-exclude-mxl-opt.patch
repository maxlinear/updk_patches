diff -Naur a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2026-01-27 11:44:00.723557866 +0100
+++ b/CMakeLists.txt	2026-01-27 11:43:02.353680963 +0100
@@ -34,7 +34,7 @@
 set(CMAKE_INCLUDE_CURRENT_DIR ON)
 set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
 set(SOFTWARE_VER "8.2.0")
-set(MXL_RV_VER "2.2")
+set(MXL_RV_VER "2.3")
 
 INCLUDE (CheckIncludeFiles)
 INCLUDE (CheckFunctionExists)
diff -Naur a/udpst.c b/udpst.c
--- a/udpst.c	2026-01-19 16:12:55.125494270 +0100
+++ b/udpst.c	2026-01-27 10:43:39.723163752 +0100
@@ -88,6 +88,7 @@
 #include <sys/epoll.h>
 #include <sys/stat.h>
 #include <sys/time.h>
+#include <getopt.h>
 #ifdef AUTH_KEY_ENABLE
 #include <openssl/hmac.h>
 #include <openssl/x509.h>
@@ -125,6 +126,7 @@
 #define ENDTEXT_BASIC "[%d]End time reached"
 #define ENDTEXT_NEWBW ENDTEXT_BASIC " (New USBW: %d, DSBW: %d)\n"
 #define NOAUTH_TEXT   "ERROR: Built without authentication functionality\n"
+#define NO_MXL_OPT 0x1001
 int errConn = -1, monConn = -1, aggConn = -1; // Error, monitoring, and aggregate
 char scratch[STRING_SIZE];                    // General purpose scratch buffer
 struct configuration conf;                    // Configuration data structure
@@ -139,6 +141,7 @@
 cJSON *json_top = NULL, *json_output = NULL, *json_siArray = NULL;
 char json_errbuf[STRING_SIZE], json_errbuf2[STRING_SIZE];
 
+static bool skip_mxl_opt = false;
 //----------------------------------------------------------------------------
 // Function definitions
 //----------------------------------------------------------------------------
@@ -250,11 +253,11 @@
         // Print banner or initialize JSON output object
         //
         if (!conf.jsonOutput) {
-#ifdef MXL_OPT
-                var = sprintf(scratch, SOFTWARE_TITLE "\nSoftware Ver: %s MxL Rev Ver: %s", SOFTWARE_VER, MXL_RV_VER);
-#else
-                var = sprintf(scratch, SOFTWARE_TITLE "\nSoftware Ver: %s", SOFTWARE_VER);
-#endif
+                if (is_mxl_opt_enabled()) {
+                        var = sprintf(scratch, SOFTWARE_TITLE "\nSoftware Ver: %s MxL Rev Ver: %s", SOFTWARE_VER, MXL_RV_VER);
+                } else {
+                        var = sprintf(scratch, SOFTWARE_TITLE "\nSoftware Ver: %s", SOFTWARE_VER);
+                }
                 if (repo.isServer)
                         var += sprintf(&scratch[var], ", Protocol Ver: %d-%d", PROTOCOL_MIN, PROTOCOL_VER);
                 else
@@ -799,7 +802,10 @@
 int proc_parameters(int argc, char **argv, int fd) {
         int i, j, var, value;
         char *lbuf, *optstring = "ud46C:x1evsf:jTDXSO:B:ri:oRa:y:K:m:I:t:P:p:A:b:L:U:F:c:h:q:E:Ml:k:?";
-
+        static const struct option mxl_opts[] = {
+                {"no-mxl-opt", no_argument, 0, NO_MXL_OPT},
+                {NULL, 0, 0, 0}
+        };
         //
         // Clear configuration and global repository data
         //
@@ -812,7 +818,7 @@
         value            = opterr;
         opterr           = 0;
         conf.controlPort = DEF_CONTROL_PORT;
-        while ((i = getopt(argc, argv, optstring)) != -1) {
+        while ((i = getopt_long(argc, argv, optstring, mxl_opts, NULL)) != -1) {
                 switch (i) {
                 case 'u':
                         conf.usTesting = TRUE;
@@ -828,6 +834,9 @@
                         }
                         conf.controlPort = value;
                         break;
+                case NO_MXL_OPT:
+                        skip_mxl_opt = true;
+                        break;
                 }
         }
 
@@ -949,7 +958,7 @@
         //
         optind = 0;
         opterr = value;
-        while ((i = getopt(argc, argv, optstring)) != -1) {
+        while ((i = getopt_long(argc, argv, optstring, mxl_opts, NULL)) != -1) {
                 switch (i) {
                 case '4':
                         conf.addrFamily = AF_INET;
@@ -1331,6 +1340,9 @@
                         }
                         conf.logFileMax = value * 1000;
                         break;
+                case NO_MXL_OPT:
+                        skip_mxl_opt = true;
+                        break;
                 case '?':
                         var = sprintf(scratch,
                                       "%s\nUsage: %s [option]... [server[:<port>]]...\n\n"
@@ -1353,6 +1365,7 @@
                         var = sprintf(scratch,
                                       "       -T           Use datagram sizes for traditional (1500 byte) MTU\n"
                                       "       -D           Enable debug output messaging (requires '-v')\n"
+                                      "       --no-mxl-opt Disable MxL optimization\n"
                                       "(m)    -X           Randomize datagram payload (else zeroes)\n"
                                       "       -S           Show server sending rate table and exit\n"
                                       "       -O file      Output (export) file of received load metadata\n"
@@ -1682,4 +1695,14 @@
 
         return repo.endTimeStatus;
 }
+
+bool is_mxl_opt_enabled(void) {
+
+#ifdef MXL_OPT
+    return !skip_mxl_opt;
+#else
+    return false;
+#endif
+}
+
 //----------------------------------------------------------------------------
diff -Naur a/udpst_control.c b/udpst_control.c
--- a/udpst_control.c	2026-01-19 16:12:55.126494271 +0100
+++ b/udpst_control.c	2026-01-27 10:42:24.748199344 +0100
@@ -1067,22 +1067,22 @@
         tspecplus(&repo.systemClock, &tspecvar, &c->timer3Thresh);
         c->timer3Action = &stop_test;
 
-#if defined(MXL_OPT)
-        int val2 = 1;
-        int opt_name = OB_UDPST;
+        if (is_mxl_opt_enabled()) {
+                int val2 = 1;
+                int opt_name = OB_UDPST;
 
-	if (is_loopback_ip(c->remAddr))
-		return 0;
+                if (is_loopback_ip(c->remAddr))
+                        return 0;
 
-        if (c->ipProtocol == IPPROTO_IPV6)
-                opt_name = OB_UDPST6;
+                if (c->ipProtocol == IPPROTO_IPV6)
+                        opt_name = OB_UDPST6;
 
-        if(setsockopt(c->fd, IPPROTO_UDP, opt_name, &val2, sizeof(val2)) < 0) {
-                var = sprintf(scratch, "SET OB_UDPST ERROR: %s\n", strerror(errno));
-                send_proc(errConn, scratch, var);
-                return -1;
+                if (setsockopt(c->fd, IPPROTO_UDP, opt_name, &val2, sizeof(val2)) < 0) {
+                        var = sprintf(scratch, "SET OB_UDPST ERROR: %s\n", strerror(errno));
+                        send_proc(errConn, scratch, var);
+                        return -1;
+                }
         }
-#endif
         return 0;
 }
 //----------------------------------------------------------------------------
@@ -1406,25 +1406,24 @@
         tspecplus(&repo.systemClock, &tspecvar, &c->timer3Thresh);
         c->timer3Action = &stop_test;
 
+        if (is_mxl_opt_enabled()) {
+                if (is_loopback_ip(c->remAddr))
+                        return 0;
 
-#if defined(MXL_OPT)
-	if (is_loopback_ip(c->remAddr))
-		return 0;
-
-        if ((c->testType == TEST_TYPE_DS)) {
-                int val2 = 1;
-                int opt_name = OB_UDPST;
-
-                if (c->ipProtocol == IPPROTO_IPV6)
-                        opt_name = OB_UDPST6;
-
-                if(setsockopt(c->fd, IPPROTO_UDP, opt_name, &val2, sizeof(val2)) < 0) {
-                        var = sprintf(scratch, "SET OB_UDPST ERROR: %s\n", strerror(errno));
-                        send_proc(errConn, scratch, var);
-                        return -1;
+                if ((c->testType == TEST_TYPE_DS)) {
+                        int val2 = 1;
+                        int opt_name = OB_UDPST;
+                        
+                        if (c->ipProtocol == IPPROTO_IPV6)
+                                opt_name = OB_UDPST6;
+
+                        if (setsockopt(c->fd, IPPROTO_UDP, opt_name, &val2, sizeof(val2)) < 0) {
+                                var = sprintf(scratch, "SET OB_UDPST ERROR: %s\n", strerror(errno));
+                                send_proc(errConn, scratch, var);
+                                return -1;
+                        }
                 }
         }
-#endif
         return 0;
 }
 //----------------------------------------------------------------------------
diff -Naur a/udpst_data.c b/udpst_data.c
--- a/udpst_data.c	2026-01-19 16:12:55.126494271 +0100
+++ b/udpst_data.c	2026-01-22 11:48:19.647317906 +0100
@@ -419,10 +419,8 @@
         j    = 0; // Message count
         cmsg = (struct cmsghdr *) cmsgbuf;
 
-#if defined(MXL_OPT)
-	if (!is_loopback_ip(c->remAddr))
-		return mxl_dp_gso(sndbuf, payload, addon, totalburst, c, burstsize, rttrd, connindex);
-#endif
+        if (is_mxl_opt_enabled() && !is_loopback_ip(c->remAddr))
+                return mxl_dp_gso(sndbuf, payload, addon, totalburst, c, burstsize, rttrd, connindex);
         while (totalburst > 0) {
                 //
                 // Fill send buffer until GSO limit or burst completion
@@ -862,15 +860,17 @@
 #endif
         BOOL bvar, firstpdu = FALSE;
         unsigned int uvar, seqno, rttrd, payload;
-#if defined(MXL_OPT)
-        struct loadHdr *lHdr = (struct loadHdr *) repo.defBuffer;
-        int udpPayloadRem = repo.rcvDataSize;
-        char *nextSeg = repo.defBuffer;
+        struct loadHdr *lHdr;
+        int udpPayloadRem;
         int udpSegLen;
-
-#else
-        struct loadHdr *lHdr = (struct loadHdr *) repo.rcvDataPtr;
-#endif
+        char *nextSeg;
+        if (is_mxl_opt_enabled()) {
+                lHdr = (struct loadHdr *) repo.defBuffer;
+                udpPayloadRem = repo.rcvDataSize;
+                nextSeg = repo.defBuffer;
+        } else { 
+                lHdr = (struct loadHdr *) repo.rcvDataPtr;
+        }
         struct timespec tspecvar, tspecdelta;
         char *nulloutput = ",,,,,\n";
 
@@ -1015,11 +1015,10 @@
                 if (c->outputFPtr != NULL) { // Finalize output data with null entries
                         fputs(nulloutput, c->outputFPtr);
                 }
-#if defined(MXL_OPT)
-                goto next_hdr_check;
-#else
-                return 0; // No further processing for non-increasing sequence numbers
-#endif //MXL_OPT
+                if (is_mxl_opt_enabled())
+                        goto next_hdr_check;
+                else
+                        return 0; // No further processing for non-increasing sequence numbers
         }
 
         //
@@ -1110,10 +1109,9 @@
                 c->sisAct.delayVarSum += (uint32_t) uvar;
                 c->sisAct.delayVarCnt++;
         }
-#if defined(MXL_OPT)
 next_hdr_check:
         udpSegLen = sizeof(struct loadHdr);
-        if (udpSegLen < udpPayloadRem) {
+        if (is_mxl_opt_enabled() && udpSegLen < udpPayloadRem) {
                 // We have received UDP_GRO segment with multiple lHdr,
                 // so iterate to next lHdr.
                 nextSeg += udpSegLen;
@@ -1121,7 +1119,6 @@
                 udpPayloadRem -= udpSegLen;
                 goto lbl_nextlhdr_gro;
         }
-#endif
         return 0;
 }
 //----------------------------------------------------------------------------
@@ -2379,15 +2376,13 @@
         //
         // Specify receive buffer size (truncate load PDUs to reduce overhead of memory copy)
         //
-#if defined(MXL_OPT)
-        recvsize = DEF_BUFFER_SIZE;
-#else
-        if (c->secAction == &service_recvmmsg || c->secAction == &service_loadpdu) {
+        if (is_mxl_opt_enabled()) {
+                recvsize = DEF_BUFFER_SIZE;
+        } else if (c->secAction == &service_recvmmsg || c->secAction == &service_loadpdu) {
                 recvsize = RCV_HEADER_SIZE;
         } else {
                 recvsize = DEF_BUFFER_SIZE;
         }
-#endif
         repo.rcvDataPtr = repo.defBuffer; // Default to start of general I/O buffer
 
         //
diff -Naur a/udpst.h b/udpst.h
--- a/udpst.h	2026-01-19 16:12:55.126494271 +0100
+++ b/udpst.h	2026-01-23 05:54:44.075467003 +0100
@@ -43,7 +43,7 @@
 #include "config.h"
 #endif /* __linux__ */
 #include "udpst_common.h"
-
+#include <stdbool.h>
 //----------------------------------------------------------------------------
 //
 // General
@@ -482,5 +482,10 @@
         struct timespec spduTime;  // Send time in last received status PDU
 };
 //----------------------------------------------------------------------------
+#ifndef MXL_OPT
+#define MXL_OPT 1
+#endif
+
+bool is_mxl_opt_enabled(void);
 
 #endif /* UDPST_H */
